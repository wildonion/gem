
           https://docs.metaplex.com/programs/understanding-programs

    ======================================
    ============= ABOUT SOLANA WALLET INFO 
    ======================================

    `solana-keygen new` will generate a new wallet info which contains 
    public and private keys produced from the elliptic curve algorithm
    based on Ed25519 which is a public key digital signature which means
    that a message came from the holder of a certain private key and that 
    the information has not been tampered with in flight; the hash of the 
    pulic key will be used as the wallet address or it can be used as it is
    in its raw format and the private key to sign transaction method calls 
    to make sure that the public key of the transaction call or the signer 
    info is the one who signed the call with his or her private key, also 
    the private key is a pen that can be used to sign 
    every program transaction call.  

    =============================================
    ============= ABOUT NULL POINTER OPTIMISATION
    =============================================

    borsh uses a null-pointer optimization in serializing Option means it takes 
    extra 1 byte instead of allocating extra 8 bytes tag which is used to 
    point to the current variant; by this it serializes an Option as 1 byte for the 
    variant identifier and then additional x bytes for the content if it's Some
    otherwise there will be just 1 byte to avoid null pointer or zero bytes,
    a null-pointer optimization means a reference can never be null since 
    Option<&T> is the exact size of the T because in enum the size of the 
    whole enum is equals to the size of the biggest variant, in Option enum 
    and all enums with two variants instead of requiring an extra word or 8 bytes 
    tag which can points to the current variant of the enum we can use the size of T
    with 1 extra byte to represent the tag to make sure that there is 
    no invalid pointer or reference.

    =========================================
    =============  SOLANA RUNTIME EXPLANATION
    =========================================

    solana runtime has its own BPF loader which supports no std libs
    since contracts can't interact with the ouside world thus there 
    is no socket to do this due to the securtiy reasons although
    the reason that solana contract gets compiled to .so is because 
    they can be loaded from the linux kernel which is blazingly 
    fast also from the browsers, a json RPC call must be invoked 
    with a contract method name and id (public key) to the RPC server 
    on the solana runtime node to load the .so contract which has bee 
    deployed and contains the BPF bytecode in it to call 
    the method name inside the incoming RPC request 
    to change the state of the blockchain.

    the reason that solana RPC data serialization is based on JSON
    is because dApps are browser based applications which don't 
    support raw TCP or UDP protocols and other serialization format 
    like capnp thus it's easier to use JSON and RPC or websocket on 
    top of http which is a layer of top of TCP protocol.

    =========================================
    ============= SOLANA ACCOUNTS EXPLANATION
    ========================================= 

    on first deployment of the contract the owner of the program is the BPF loader
    itself also a new key pair will be generated and used to deploy the contract 
    on it which is the address that the BPF bytecode is located, in order to 
    amend any instruction data on the contract the account that wants to amend 
    must be the owner of the program id or the public key of the program account 
    means account.owner == program_id which this will be checked by Account type 
    in anchor that will check the owner of instruction data or the serialized 
    data passed in to the function equals to the program id public key to modify 
    the data on chain in other words the mutation method must be called only by 
    contract method itself not a third party account.

    accounts on solana can be used to store data inside of them in which the data 
    inside a specific account can only be modified by the account owner means the 
    owner must be the program id and the runtime grants the program write access 
    to the account if its id matches the owner.

    authority is the program's upgrade authority, the one who can sign transactions 
    on behalf of the account and who has deployed the program and has access to change 
    the program content thus is the owner of the program.

    singer is the private key holder and the one who can signs the transaction 
    with his or her private key, PDA is an off curve address with no private 
    key that can be used as a staking pool account for transferring and 
    withdrawing lamports since it has no private key thus no one can sign 
    a transaction call to that address to mutate the state of the account; 
    the PDA can be generated from a seed which can be a unique indentifer 
    like public key plus a bump which is a one byte number.

    PDA can be used to generate signature to be used for calling between programs
    since they have no private keys thus no third party can sign the transaction
    only the PDA owner can do this (without private key) which can be used for 
    signing a transaction method call of another contract and also used for 
    depositing/withdrawing lamports as a escrow contract.


    program id: is the public key of the deployed program which is inside the target/deploy
    authority : is the upgrade authority or the owner of the deployed contract
    owner     : is the one who can mutate instruction data on the chain; owner == program_id means only the program account can mutate data on the chain 
    holder    : is the one who has the generated private key from the Ed25519 elliptic curve 
    signer    : is the private key holder and can sign tx call
    PDA       : is an off curve public key that can be used as the escrow account 


    in our case the game_state field is an account over generic GameState
    in which its owner must equals to the id inside the declare_id which is 
    the id of the program also the #[accounts] proc macro attribute sets the 
    owner of the GameState data to the declare_id in order to be able to mutate
    data on the chain since only the account that owns the program can amend data
    over some generic thus game_state is a field in all structures that has write 
    access to mutate and change GameState data in this program; the game_state
    field is also a PDA accounts since a transaction method call on the owner account 
    the game_state account might be came from a server (not the frontend itself 
    where we have access the program account) which wants to amend data on the chain.